<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>RomWBW Emulator</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
  <style>
    body {
      background: #1a1a2e;
      color: #eee;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    h1 {
      color: #00aaff;
      margin-bottom: 10px;
    }
    #status {
      color: #888;
      margin-bottom: 10px;
      font-size: 14px;
    }
    #terminal-container {
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      display: inline-block;
    }
    .controls {
      margin: 15px 0;
    }
    button {
      background: #0066aa;
      color: white;
      border: none;
      padding: 4px 12px;
      margin-right: 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover {
      background: #0088cc;
    }
    button:disabled {
      background: #555;
      cursor: not-allowed;
    }
    .file-input {
      margin: 4px 0;
    }
    label {
      display: inline-block;
      margin-right: 8px;
      font-size: 13px;
    }
    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .info {
      font-size: 12px;
      color: #666;
    }
    .instructions {
      margin-top: 20px;
      padding: 15px;
      background: #222;
      border-radius: 8px;
      font-size: 13px;
      max-width: 700px;
    }
    .instructions h3 {
      color: #00aaff;
      margin-top: 0;
    }
    .instructions code {
      background: #333;
      padding: 2px 6px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="header-row">
    <h1>RomWBW Emulator <a href="https://github.com/avwohl/cpmemu" style="font-size:12px;color:#888;margin-left:10px;">[sources]</a></h1>
    <span id="status" style="color:#888;font-size:14px;">Loading...</span>
    <span class="info">512KB ROM + 512KB RAM | Z80 | v@VERSION@</span>
  </div>

  <div class="controls">
    <div class="file-input">
      <label>ROM:</label>
      <select id="romSelect" style="margin-right:4px;">
        <option value="">-- Select ROM --</option>
        <option value="emu_avw.rom" selected>emu_avw.rom (Emulator HBIOS - recommended)</option>
        <option value="SBC_simh_std.rom">SBC_simh_std.rom (SIMH hardware)</option>
      </select>
      <input type="file" id="romFile" accept=".rom,.bin" style="width:180px;">
      <label style="margin-left:12px;">Boot:</label><input type="text" id="bootString" placeholder="2=disk, C=CPM" style="width:100px;" value="2">
    </div>
    <div class="file-input">
      <label>Disk 0 (C:):</label>
      <select id="disk0Select" style="margin-right:4px;">
        <option value="">-- Select Disk (hd1k format) --</option>
        <option value="hd1k_combo.img" selected>hd1k_combo.img (49MB combo disk)</option>
        <option value="hd1k_games.img">hd1k_games.img (Classic games: Zork, Adventure)</option>
        <option value="hd1k_cpm22.img">hd1k_cpm22.img (CP/M 2.2)</option>
        <option value="hd1k_zsdos.img">hd1k_zsdos.img (ZSDOS)</option>
      </select>
      <input type="file" id="disk0File" accept=".img,.dsk" style="width:140px;">
      <button id="downloadDisk0Btn" disabled title="Download modified disk">↓</button>
    </div>
    <div class="file-input">
      <label>Disk 1 (D:):</label>
      <select id="disk1Select" style="margin-right:4px;">
        <option value="">-- None --</option>
        <option value="hd1k_games.img" selected>hd1k_games.img (Classic games)</option>
        <option value="hd1k_cpm22.img">hd1k_cpm22.img (CP/M 2.2)</option>
        <option value="hd1k_zsdos.img">hd1k_zsdos.img (ZSDOS)</option>
      </select>
      <input type="file" id="disk1File" accept=".img,.dsk" style="width:140px;">
      <button id="downloadDisk1Btn" disabled title="Download modified disk">↓</button>
      <button id="startBtn" style="margin-left:20px;">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <label style="margin-left:20px;"><input type="checkbox" id="debugCheckbox"> Debug</label>
    </div>
  </div>

  <div id="terminal-container">
    <div id="terminal"></div>
  </div>

  <div class="instructions">
    <h3>Quick Start</h3>
    <p>1. Click <strong>Start</strong> to boot with games disk (default settings)</p>
    <p>2. At <code>C&gt;</code> prompt, type <code>DIR</code> to see files, or run a game like <code>ZORK1</code></p>

    <h3>ROM Types</h3>
    <p><code>emu_avw.rom</code> - <strong>Recommended.</strong> Uses emulator's C++ HBIOS. Works with all hd1k disk images.</p>
    <p><code>SBC_simh_std.rom</code> - Original SIMH ROM. Requires SIMH hardware emulation (may not boot).</p>

    <h3>Disk Images (hd1k format, 8MB)</h3>
    <p><code>hd1k_games.img</code> - Classic games: Colossal Cave Adventure, Castle, Dungeon, Hitchhiker's</p>
    <p><code>hd1k_infocom.img</code> - Infocom text adventures: Zork 1-3, Hitchhiker's Guide, Enchanter trilogy</p>
    <p><code>hd1k_cpm22.img</code> / <code>hd1k_zsdos.img</code> - Operating system disks</p>

    <h3>Boot Options</h3>
    <p><code>2</code> - Boot from disk (drive C:) | <code>C</code> - CP/M from ROM | <code>H</code> - Help</p>

    <h3>Drive Letters</h3>
    <p><code>A:</code> RAM disk | <code>B:</code> ROM disk | <code>C:</code> Disk 0 | <code>D:</code> Disk 1</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script src="romwbw.js"></script>
  <script>
    const EMU_VERSION = '@VERSION@';

    // Terminal setup
    const term = new Terminal({
      cols: 80,
      rows: 25,
      cursorBlink: true,
      fontSize: 16,
      fontFamily: 'Consolas, Monaco, monospace',
      theme: {
        background: '#0a0a1a',
        foreground: '#00aaff',
        cursor: '#00aaff'
      }
    });
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.open(document.getElementById('terminal'));
    fitAddon.fit();

    const statusDiv = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const debugCheckbox = document.getElementById('debugCheckbox');
    const romFile = document.getElementById('romFile');
    const disk0File = document.getElementById('disk0File');
    const disk1File = document.getElementById('disk1File');
    const downloadDisk0Btn = document.getElementById('downloadDisk0Btn');
    const downloadDisk1Btn = document.getElementById('downloadDisk1Btn');

    let romLoaded = false;
    let diskLoaded = [false, false];

    // Console output from emulator
    Module.onConsoleOutput = function(ch) {
      if (ch === 13) {  // CR
        term.write('\r');  // Just carriage return
      } else if (ch === 10) {  // LF
        term.write('\r\n');  // LF needs CR+LF for xterm
      } else if (ch === 8) {  // Backspace
        term.write('\b \b');
      } else if (ch >= 32 && ch < 127) {
        term.write(String.fromCharCode(ch));
      }
    };

    // Status messages from emulator
    Module.onStatus = function(msg) {
      statusDiv.textContent = msg;
    };

    //=========================================================================
    // VDA (Video Display Adapter) callbacks
    //=========================================================================

    // Track VDA cursor separately from terminal cursor
    let vdaCursorRow = 0;
    let vdaCursorCol = 0;
    let vdaAttr = 0x07;
    let vdaFg = 7;
    let vdaBg = 0;

    // ANSI color codes (CGA palette)
    const ansiColors = [
      '#000000', // 0: Black
      '#0000AA', // 1: Blue
      '#00AA00', // 2: Green
      '#00AAAA', // 3: Cyan
      '#AA0000', // 4: Red
      '#AA00AA', // 5: Magenta
      '#AA5500', // 6: Brown/Yellow
      '#AAAAAA', // 7: Light Gray
      '#555555', // 8: Dark Gray
      '#5555FF', // 9: Light Blue
      '#55FF55', // 10: Light Green
      '#55FFFF', // 11: Light Cyan
      '#FF5555', // 12: Light Red
      '#FF55FF', // 13: Light Magenta
      '#FFFF55', // 14: Yellow
      '#FFFFFF'  // 15: White
    ];

    Module.onVdaInit = function(rows, cols) {
      // Initialize video display
      term.clear();
      vdaCursorRow = 0;
      vdaCursorCol = 0;
      console.log('VDA Init: ' + rows + 'x' + cols);
    };

    Module.onVdaClear = function() {
      term.clear();
      vdaCursorRow = 0;
      vdaCursorCol = 0;
    };

    Module.onVdaSetCursor = function(row, col) {
      vdaCursorRow = row;
      vdaCursorCol = col;
      // Use ANSI escape sequence to position cursor (1-based)
      term.write('\x1b[' + (row + 1) + ';' + (col + 1) + 'H');
    };

    Module.onVdaWriteChar = function(ch, attr) {
      // Apply attribute if different
      if (attr !== vdaAttr) {
        vdaAttr = attr;
        // Convert attribute to ANSI colors (simple: low nibble = fg, high nibble = bg)
        let fg = attr & 0x0F;
        let bg = (attr >> 4) & 0x07;
        term.write('\x1b[' + (30 + (fg & 7)) + ';' + (40 + bg) + 'm');
      }
      if (ch >= 32 && ch < 127) {
        term.write(String.fromCharCode(ch));
      } else if (ch === 13) {
        term.write('\r');
      } else if (ch === 10) {
        term.write('\n');
      }
    };

    Module.onVdaFill = function(row, col, count, ch, attr) {
      // Position cursor and fill with character
      term.write('\x1b[' + (row + 1) + ';' + (col + 1) + 'H');
      const fillChar = (ch >= 32 && ch < 127) ? String.fromCharCode(ch) : ' ';
      term.write(fillChar.repeat(count));
    };

    Module.onVdaScroll = function(lines) {
      if (lines > 0) {
        // Scroll up: use ANSI scroll up
        term.write('\x1b[' + lines + 'S');
      } else if (lines < 0) {
        // Scroll down: use ANSI scroll down
        term.write('\x1b[' + (-lines) + 'T');
      }
    };

    Module.onVdaSetAttr = function(attr) {
      vdaAttr = attr;
      let fg = attr & 0x0F;
      let bg = (attr >> 4) & 0x07;
      term.write('\x1b[' + (30 + (fg & 7)) + ';' + (40 + bg) + 'm');
    };

    Module.onVdaSetColor = function(fg, bg) {
      vdaFg = fg;
      vdaBg = bg;
      term.write('\x1b[' + (30 + (fg & 7)) + ';' + (40 + (bg & 7)) + 'm');
    };

    //=========================================================================
    // Sound callbacks (using Web Audio API)
    //=========================================================================

    let audioContext = null;

    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    Module.onSndReset = function() {
      // Stop all sounds
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
    };

    Module.onSndBeep = function(freq, duration_ms) {
      try {
        const ctx = getAudioContext();
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);

        oscillator.type = 'square';  // Retro sound
        oscillator.frequency.value = freq;
        gainNode.gain.value = 0.1;   // Not too loud

        oscillator.start();
        oscillator.stop(ctx.currentTime + duration_ms / 1000);
      } catch (e) {
        console.log('Sound error:', e);
      }
    };

    Module.onSndNote = function(channel, note, duration_ms) {
      // Convert MIDI note number to frequency: f = 440 * 2^((n-69)/12)
      const freq = 440 * Math.pow(2, (note - 69) / 12);
      Module.onSndBeep(freq, duration_ms);
    };

    Module.onSndVolume = function(channel, volume) {
      // Volume control (0-255) - could be used to adjust gain
      console.log('Sound volume:', channel, volume);
    };

    // Keyboard input to emulator
    term.onKey(function(e) {
      if (Module._romwbw_key_input) {
        let ch = e.key.charCodeAt(0);
        if (e.key === 'Enter') ch = 13;
        else if (e.key === 'Backspace') ch = 8;
        else if (e.key === 'Delete') ch = 127;
        else if (e.key === 'Escape') ch = 27;
        // Handle Ctrl+key combinations
        if (e.domEvent.ctrlKey && e.key.length === 1) {
          ch = e.key.toUpperCase().charCodeAt(0) - 64;
          if (ch < 0) ch = 0;
          if (ch > 31) ch = 31;
        }
        Module._romwbw_key_input(ch);
      }
    });

    // Helper to load ROM data into emulator
    function loadRomData(data, name) {
      const ptr = Module._malloc(data.length);
      Module.HEAPU8.set(data, ptr);
      Module._romwbw_load_rom(ptr, data.length);
      Module._free(ptr);
      romLoaded = true;
      statusDiv.textContent = 'ROM loaded: ' + name + ' (' + data.length + ' bytes)';
    }

    // Helper to load disk data into emulator
    function loadDiskData(unit, data, name) {
      const ptr = Module._malloc(data.length);
      Module.HEAPU8.set(data, ptr);
      Module._romwbw_load_disk(unit, ptr, data.length);
      Module._free(ptr);
      diskLoaded[unit] = true;
      if (unit === 0) downloadDisk0Btn.disabled = false;
      if (unit === 1) downloadDisk1Btn.disabled = false;
      statusDiv.textContent = 'Disk ' + unit + ' loaded: ' + name;
    }

    // Load ROM from server select
    document.getElementById('romSelect').addEventListener('change', function(e) {
      const filename = e.target.value;
      if (!filename) return;
      statusDiv.textContent = 'Loading ' + filename + '...';
      fetch(filename)
        .then(r => r.arrayBuffer())
        .then(buf => {
          loadRomData(new Uint8Array(buf), filename);
          romFile.value = '';  // Clear file input
        })
        .catch(err => { statusDiv.textContent = 'Error loading ROM: ' + err; });
    });

    // Load ROM file from local
    romFile.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        loadRomData(new Uint8Array(e.target.result), file.name);
        document.getElementById('romSelect').value = '';  // Clear select
      };
      reader.readAsArrayBuffer(file);
    });

    // Load disk 0 from server select
    document.getElementById('disk0Select').addEventListener('change', function(e) {
      const filename = e.target.value;
      if (!filename) return;
      statusDiv.textContent = 'Loading ' + filename + '...';
      fetch(filename)
        .then(r => r.arrayBuffer())
        .then(buf => {
          loadDiskData(0, new Uint8Array(buf), filename);
          disk0File.value = '';
        })
        .catch(err => { statusDiv.textContent = 'Error loading disk: ' + err; });
    });

    // Load disk 0 file from local
    disk0File.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        loadDiskData(0, new Uint8Array(e.target.result), file.name);
        document.getElementById('disk0Select').value = '';
      };
      reader.readAsArrayBuffer(file);
    });

    // Load disk 1 from server select
    document.getElementById('disk1Select').addEventListener('change', function(e) {
      const filename = e.target.value;
      if (!filename) return;
      statusDiv.textContent = 'Loading ' + filename + '...';
      fetch(filename)
        .then(r => r.arrayBuffer())
        .then(buf => {
          loadDiskData(1, new Uint8Array(buf), filename);
          disk1File.value = '';
        })
        .catch(err => { statusDiv.textContent = 'Error loading disk: ' + err; });
    });

    // Load disk 1 file from local
    disk1File.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        loadDiskData(1, new Uint8Array(e.target.result), file.name);
        document.getElementById('disk1Select').value = '';
      };
      reader.readAsArrayBuffer(file);
    });

    // Debug checkbox
    debugCheckbox.addEventListener('change', function() {
      if (Module._romwbw_set_debug) {
        Module._romwbw_set_debug(debugCheckbox.checked ? 1 : 0);
      }
    });

    // Start button
    startBtn.addEventListener('click', async function() {
      startBtn.disabled = true;
      term.clear();
      term.writeln('RomWBW Emulator v' + EMU_VERSION);
      term.writeln('');

      // Auto-load default ROM if none loaded
      if (!romLoaded) {
        const defaultRom = 'emu_avw.rom';
        statusDiv.textContent = 'Loading default ROM...';
        try {
          const response = await fetch(defaultRom);
          const buf = await response.arrayBuffer();
          loadRomData(new Uint8Array(buf), defaultRom);
          document.getElementById('romSelect').value = defaultRom;
        } catch (err) {
          statusDiv.textContent = 'Error loading ROM: ' + err;
          startBtn.disabled = false;
          return;
        }
      }

      // Auto-load default disk 0 if none loaded
      if (!diskLoaded[0]) {
        const defaultDisk = 'hd1k_combo.img';
        statusDiv.textContent = 'Loading default disk 0...';
        try {
          const response = await fetch(defaultDisk);
          const buf = await response.arrayBuffer();
          loadDiskData(0, new Uint8Array(buf), defaultDisk);
          document.getElementById('disk0Select').value = defaultDisk;
        } catch (err) {
          // Disk is optional, just log warning
          console.log('Could not load default disk 0:', err);
        }
      }

      // Auto-load default disk 1 if none loaded
      if (!diskLoaded[1]) {
        const defaultDisk1 = 'hd1k_games.img';
        statusDiv.textContent = 'Loading default disk 1...';
        try {
          const response = await fetch(defaultDisk1);
          const buf = await response.arrayBuffer();
          loadDiskData(1, new Uint8Array(buf), defaultDisk1);
          document.getElementById('disk1Select').value = defaultDisk1;
        } catch (err) {
          // Disk is optional, just log warning
          console.log('Could not load default disk 1:', err);
        }
      }

      // Set boot string if provided
      const bootStr = document.getElementById('bootString').value.trim();
      if (bootStr && Module._romwbw_set_boot_string) {
        // Pass the string to the emulator (allocate temp buffer)
        const len = bootStr.length + 1;
        const ptr = Module._malloc(len);
        for (let i = 0; i < bootStr.length; i++) {
          Module.HEAPU8[ptr + i] = bootStr.charCodeAt(i);
        }
        Module.HEAPU8[ptr + bootStr.length] = 0;  // Null terminate
        Module._romwbw_set_boot_string(ptr);
        Module._free(ptr);
        term.writeln('Auto-boot: ' + bootStr);
      }

      Module._romwbw_start();
      if (debugCheckbox.checked) startDebugMonitor();  // Start monitoring only if debug enabled
      stopBtn.disabled = false;
      term.focus();
    });

    // Stop button
    stopBtn.addEventListener('click', function() {
      Module._romwbw_stop();
      stopDebugMonitor();  // Stop monitoring
      startBtn.disabled = false;
      stopBtn.disabled = true;
      statusDiv.textContent = 'Stopped';
    });

    // Download disk 0
    downloadDisk0Btn.addEventListener('click', function() {
      const size = Module._romwbw_get_disk_size(0);
      const ptr = Module._romwbw_get_disk_data(0);
      if (ptr && size > 0) {
        const data = new Uint8Array(Module.HEAPU8.buffer, ptr, size);
        const blob = new Blob([data], {type: 'application/octet-stream'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'romwbw_disk0.img';
        a.click();
        URL.revokeObjectURL(url);
      }
    });

    // Download disk 1
    downloadDisk1Btn.addEventListener('click', function() {
      const size = Module._romwbw_get_disk_size(1);
      const ptr = Module._romwbw_get_disk_data(1);
      if (ptr && size > 0) {
        const data = new Uint8Array(Module.HEAPU8.buffer, ptr, size);
        const blob = new Blob([data], {type: 'application/octet-stream'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'romwbw_disk1.img';
        a.click();
        URL.revokeObjectURL(url);
      }
    });

    // Click on terminal to focus it
    document.getElementById('terminal-container').addEventListener('click', function() {
      term.focus();
    });

    // Debug monitoring - tracks emulator state periodically
    let debugMonitorId = null;
    let lastInstructionCount = 0;
    let noProgressCount = 0;

    function startDebugMonitor() {
      if (debugMonitorId) return;
      lastInstructionCount = 0;
      noProgressCount = 0;
      debugMonitorId = setInterval(() => {
        if (!Module._romwbw_is_running) return;
        const running = Module._romwbw_is_running();
        const waiting = Module._romwbw_is_waiting ? Module._romwbw_is_waiting() : -1;
        const pc = Module._romwbw_get_pc();
        const instr = Module._romwbw_get_instruction_count();
        const progress = instr - lastInstructionCount;

        if (progress === 0) {
          noProgressCount++;
          console.log(`[DEBUG] NO PROGRESS #${noProgressCount}: running=${running} waiting=${waiting} PC=0x${pc.toString(16)} instr=${instr}`);
          if (noProgressCount >= 10) {
            console.error('[DEBUG] HUNG - 10+ cycles with no progress');
          }
        } else {
          if (noProgressCount > 0) {
            console.log(`[DEBUG] Progress resumed: ${progress} instructions`);
          }
          noProgressCount = 0;
        }
        lastInstructionCount = instr;

        if (!running) {
          console.log('[DEBUG] Emulator stopped');
          stopDebugMonitor();
        }
      }, 500);
    }

    function stopDebugMonitor() {
      if (debugMonitorId) {
        clearInterval(debugMonitorId);
        debugMonitorId = null;
      }
    }

    // Wait for WASM to load
    Module.onRuntimeInitialized = function() {
      statusDiv.textContent = 'Ready - Load a ROM or click Start';
      startBtn.disabled = false;
      term.writeln('RomWBW Emulator v' + EMU_VERSION + ' ready.');
      term.writeln('Load a ROM image or click Start to boot.');
      term.writeln('');
    };
  </script>
</body>
</html>
